###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     09/May/2013  16:43:54 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\Source\DS #
#                    PSPI.c                                                   #
#    Command line =  E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\Source\DS #
#                    PSPI.c -D _DEBUG=1 -lC "E:\Freescale\mqx_test\YD_PRJ_NEW #
#                    _20130323_git_\IAR\twrk60n512\Int Flash Debug\List\"     #
#                    -lA "E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\ #
#                    twrk60n512\Int Flash Debug\List\" --diag_suppress        #
#                    Pa039,Pa082,Pe186 -o "E:\Freescale\mqx_test\YD_PRJ_NEW_2 #
#                    0130323_git_\IAR\twrk60n512\Int Flash Debug\Obj\"        #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\..\li #
#                    b\twrk60n512.iar\ -I E:\Freescale\mqx_test\YD_PRJ_NEW_20 #
#                    130323_git_\IAR\..\lib\twrk60n512.iar\bsp\ -I            #
#                    E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\..\li #
#                    b\twrk60n512.iar\psp\ -I E:\Freescale\mqx_test\YD_PRJ_NE #
#                    W_20130323_git_\IAR\..\lib\twrk60n512.iar\bsp\Generated_ #
#                    Code\ -I E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\ #
#                    IAR\..\lib\twrk60n512.iar\rtcs\ -I                       #
#                    E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\..\li #
#                    b\twrk60n512.iar\mfs\ -I E:\Freescale\mqx_test\YD_PRJ_NE #
#                    W_20130323_git_\IAR\..\lib\twrk60n512.iar\usb\host\ -I   #
#                    E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\..\li #
#                    b\twrk60n512.iar\shell\ -I E:\Freescale\mqx_test\YD_PRJ_ #
#                    NEW_20130323_git_\IAR\..\lib\twrk60n512.iar\usb\ -I      #
#                    E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\..\   #
#                    -I E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\.. #
#                    \Source\Source_MQX\ -I E:\Freescale\mqx_test\YD_PRJ_NEW_ #
#                    20130323_git_\IAR\..\Source\ -I "E:\Freescale\Freescale  #
#                    MQX 3.8\shell\source\include\" -Ol --use_c++_inline      #
#    List file    =  E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\twrk6 #
#                    0n512\Int Flash Debug\List\DSPSPI.lst                    #
#    Object file  =  E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\IAR\twrk6 #
#                    0n512\Int Flash Debug\Obj\DSPSPI.o                       #
#                                                                             #
#                                                                             #
###############################################################################

E:\Freescale\mqx_test\YD_PRJ_NEW_20130323_git_\Source\DSPSPI.c
      1          /*******************************************************************************
      2          * File Name        : DSPSPI.c
      3          * Author             : LB&TX
      4          * Version            : V1.0.0
      5          * Date                :
      6          * Description        :SPI使用的是430的UartB1口。
      7                                 SPI时钟由主机控制，
      8                                 
      9          *******************************************************************************/
     10          #include "includes.h"
     11          
     12          #define _SPIDMADATA_DBUG_  // 是否有 DBUG 输出信息
     13          
     14          //U8 BufRxchar[ARRAY_SIZE]= {0};//转存数组，仅在此C文件中使用

   \                                 In section .bss, align 4
     15          U8 BufRxchar[6175]= {0};// wk -->转存数组，仅在此C文件中使用
   \                     BufRxchar:
   \   00000000                      DS8 6176

   \                                 In section .bss, align 4
     16          U8 PowRxchar[Pow_SIZE]= {0}; //去除起始符结束符的有效数据，通信协议中的数据长度减去结束符
   \                     PowRxchar:
   \   00000000                      DS8 2532

   \                                 In section .bss, align 4
     17          U8 EvntRxchar[Evnt_SIZE]= {0};
   \                     EvntRxchar:
   \   00000000                      DS8 6148

   \                                 In section .bss, align 1
     18          U8 SPIRxCnt=0;   //SPI接收标志，作用域在此文件
   \                     SPIRxCnt:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     19          U16 TotalNum=0;//需接收数据的长度，作用域在此文件
   \                     TotalNum:
   \   00000000                      DS8 2
     20          //U8 DataType=0;//作用域在此文件
     21          //U8 HeadFlg[4]={0}; // wk @20130325 -->  // wk @130403 --> uncomment

   \                                 In section .bss, align 1
     22          volatile U8 SPIPowerFlg;//默认值0
   \                     SPIPowerFlg:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     23          volatile U8 SPIEventFlg;//默认值0
   \                     SPIEventFlg:
   \   00000000                      DS8 1
     24          

   \                                 In section .data, align 2
     25          U16 DataSize = ARRAY_SIZE ;  //wk -->传给 DMA 寄存器的一次服务数据长度
   \                     DataSize:
   \   00000000   0x0001             DC16 1

   \                                 In section .bss, align 1
     26          volatile static uchar count=0; // 用于数据头检测
   \                     count:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     27          U8 SPI_Send=0; // wk @130406 --> K60是否给DSP发送数据的标志
   \                     SPI_Send:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     28          U8 HeadFlg[6]={0};
   \                     HeadFlg:
   \   00000000                      DS8 8
     29          //volatile U16 Time_save=0;  //备份事件参数
     30          //volatile U8 testflgg=0;   //MCU发送数据个数
     31          

   \                                 In section .bss, align 4
     32          MQX_FILE_PTR spifd_2; //spifd_2 --> spi2设备的句柄
   \                     spifd_2:
   \   00000000                      DS8 4
     33          
     34           // wk @130403 --> uncomment
     35          //GPIO_PIN_STRUCT pins_int[] = {    /* PTB10 定义结构体 */  // 定义 PTB10 上升沿中断
     36          //            BSP_PTB10 | GPIO_PIN_IRQ_FALLING,
     37          //            GPIO_LIST_END
     38          //            };
     39          
     40          /* wk --> 初始化与 DSP 通信使用的 SPI2 */

   \                                 In section .text, align 2, keep-with-next
     41          void spi2_dma_int(void)
     42          {
   \                     spi2_dma_int:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     43            uint_32                param;
     44          // @20130312 --> wk
     45          //  spi_rw.BUFFER_LENGTH = 1; //初始化 spi_rw结构体数据长度
     46            /**************************** spi2 configure *************************/
     47          #ifdef _SPIDBG_ 
     48              printf("\n-------------- Int SPI2 configure --------------\n\n");
     49          #endif
     50          //     /* Open the SPI driver */
     51             spifd_2 = fopen(TEST_CHANNEL_INT2,NULL);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable2_1
   \   00000008   0x.... 0x....      BL       _io_fopen
   \   0000000C   0x....             LDR.N    R1,??DataTable2_2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     52               
     53             if (NULL == spifd_2)
   \   00000010   0x....             LDR.N    R0,??DataTable2_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE.N    ??spi2_dma_int_0
     54             {
     55                printf ("Error opening SPI driver!\n");
   \   00000018   0x....             LDR.N    R0,??DataTable2_3
   \   0000001A   0x.... 0x....      BL       _io_printf
     56                _time_delay (200L);
   \   0000001E   0x20C8             MOVS     R0,#+200
   \   00000020   0x.... 0x....      BL       _time_delay
     57                _task_block ();
   \   00000024   0x.... 0x....      BL       _task_block
     58             }
     59          
     60             /* Set clock mode */
     61                param = SPI_CLK_POL_PHA_MODE1;
   \                     ??spi2_dma_int_0:
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x9000             STR      R0,[SP, #+0]
     62             if (SPI_OK == ioctl (spifd_2, IO_IOCTL_SPI_SET_MODE, &param))
   \   0000002C   0xAA00             ADD      R2,SP,#+0
   \   0000002E   0xF640 0x6104      MOVW     R1,#+3588
   \   00000032   0x....             LDR.N    R0,??DataTable2_2
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       _io_ioctl
   \   0000003A   0x0004             MOVS     R4,R0
     63             {
     64          #ifdef _SPIDBG_
     65                printf ("SPI2 is OK!\n");
     66          #endif
     67             } else {
     68          #ifdef _SPIDBG_
     69                printf ("ERROR\n");
     70          #endif
     71             }
     72          
     73             /* Set big endian */
     74             param = SPI_DEVICE_BIG_ENDIAN;    // wk -->这个设置是针对主机来说的，对于从机时设置都会出错
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9000             STR      R0,[SP, #+0]
     75          //   printf ("Setting endian to %s ... ", param == SPI_DEVICE_BIG_ENDIAN ? "SPI_DEVICE_BIG_ENDIAN" : "SPI_DEVICE_LITTLE_ENDIAN");
     76             if (SPI_OK == ioctl (spifd_2, IO_IOCTL_SPI_SET_ENDIAN, &param))
   \   00000040   0xAA00             ADD      R2,SP,#+0
   \   00000042   0xF640 0x610A      MOVW     R1,#+3594
   \   00000046   0x....             LDR.N    R0,??DataTable2_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       _io_ioctl
   \   0000004E   0x0005             MOVS     R5,R0
     77             {
     78          #ifdef _SPIDBG_
     79                printf ("OK\n");
     80          #endif   
     81             } else {
     82          #ifdef _SPIDBG_     
     83                printf ("ERROR\n");
     84          #endif      
     85             }
     86                /* Set transfer mode */
     87             param = SPI_DEVICE_SLAVE_MODE;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x9000             STR      R0,[SP, #+0]
     88          //   printf ("Setting SPI2 transfer mode to %s ... ", device_mode[param]);
     89             if (SPI_OK == ioctl (spifd_2, IO_IOCTL_SPI_SET_TRANSFER_MODE, &param))
   \   00000054   0xAA00             ADD      R2,SP,#+0
   \   00000056   0xF640 0x6108      MOVW     R1,#+3592
   \   0000005A   0x....             LDR.N    R0,??DataTable2_2
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       _io_ioctl
   \   00000062   0x0006             MOVS     R6,R0
     90             {
     91          #ifdef _SPIDBG_      
     92                printf ("OK\n");
     93          #endif     
     94             } else {
     95          #ifdef _SPIDBG_
     96                printf ("ERROR\n");
     97          #endif      
     98             }
     99             /* Clear statistics */
    100          //   printf ("Clearing statistics ... ");
    101             if (SPI_OK == ioctl (spifd_2, IO_IOCTL_SPI_CLEAR_STATS, NULL))
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0xF44F 0x6161      MOV      R1,#+3600
   \   0000006A   0x....             LDR.N    R0,??DataTable2_2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       _io_ioctl
    102             {
    103           #ifdef _SPIDBG_    
    104                printf ("OK\n");
    105           #endif 
    106             } else {
    107           #ifdef _SPIDBG_     
    108                printf ("ERROR\n");
    109            #endif     
    110             }
    111           #ifdef _SPIDBG_  
    112             printf("\n--------------       End       --------------\n\n");
    113           #endif  
    114             /******************************* spi2 conf end ****************************/
    115          }
   \   00000072   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    116          
    117          /* wk --> 初始化 PTB10 用于数据中断接收 */  // wk @130403 --> uncomment
    118          //inline void ptb_10_int(void)
    119          //{
    120          // /* wk --> set gpio of ptb10 in int mode for spi data read */
    121          //    ptbfd_10 = fopen("gpio:read", (char_ptr) &pins_int );
    122          //    ioctl(ptbfd_10,GPIO_IOCTL_SET_IRQ_FUNCTION, (pointer)int_callback);
    123          ///* end */
    124          //}
    125          
    126          /*
    127          ** 函数名：
    128          ** 作者：
    129          ** 说明：在没有使用事件时 SPI 接收数据的外部函数
    130          ** 测试记录：wk@130408-->数据发送：5个数据头（4个数据头+1个启动信号）+正常数据，注意，这次测试结果表明，数据没有丢失
    131          */

   \                                 In section .text, align 4, keep-with-next
    132          void DMA_RecData_OK  
    133          (
    134            void
    135          )
    136          {
   \                     DMA_RecData_OK:
   \   00000000   0xB580             PUSH     {R7,LR}
    137          #if 0 // wk @130412 --> 旧协议  
    138              if(count<4)
    139              {
    140                HeadFlg[count]=BufRxchar[0];
    141                count++;
    142                if(count==4)
    143                  if(HeadFlg[0]==0x33 && HeadFlg[1]==0x33 && HeadFlg[2]==0x33 && (HeadFlg[3]== 0x44 ||HeadFlg[3]== 0x55))
    144                  {
    145                    if(HeadFlg[3]==0x44)
    146                      DataSize= 2556; // wk @130420 -->发送数据 4+1+14+2+2532+12+4=2560
    147                    else
    148                      DataSize= Evnt_SIZE + 4; // wk @20130325 -->
    149                    
    150                      count=5; //  wk --> 数据头已经找到 
    151          //          printf("\n1");
    152                  }
    153                  else
    154                  {
    155                    HeadFlg[0]=HeadFlg[1];
    156                    HeadFlg[1]=HeadFlg[2];
    157                    HeadFlg[2]=HeadFlg[3];
    158                    count=3;
    159                  }
    160               
    161              }
    162              else if(count==5)
    163              {
    164                   count=6; // 用一个数据改变 DMA 接收数据的长度，此数据将会被舍弃        
    165          //         SPI_Send=1; // wk @130406 --> K60是否给DSP发送数据的标志
    166              }
    167              else
    168              {
    169                /* wk @130408 --> data trans */ 
    170                 if(HeadFlg[3]==0x44) // wk @20130325 -->
    171                   for(int i=0;i<Pow_SIZE;i++)
    172                   {
    173                     PowRxchar[i] = BufRxchar[i+OffSET];
    174                     SPIPowerFlg=1;
    175                   }
    176                 else
    177                     printf("Event\n");  // 事件数据还没有处理
    178                 
    179          //        printf("%x\t%x\n",BufRxchar[0],BufRxchar[1]); // test 
    180                  count=0; 
    181                  DataSize=1;
    182                  SPI_Send=0;
    183                  fclose(spifd_2);
    184                  asm("NOP");  
    185                  spi2_dma_int(); // 刷新 DMA 寄存器
    186                  asm("NOP");   
    187              }
    188          #endif 
    189                   /* wk @130412 -->基于新协议 */
    190          #if 1
    191              if(count<6)
   \   00000002   0x....             LDR.N    R0,??DataTable2_4
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2806             CMP      R0,#+6
   \   00000008   0xD243             BCS.N    ??DMA_RecData_OK_0
    192              {
    193                HeadFlg[count]=BufRxchar[0];
   \   0000000A   0x....             LDR.N    R0,??DataTable2_4
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable2_5
   \   00000010   0x....             LDR.N    R2,??DataTable2_6
   \   00000012   0x7812             LDRB     R2,[R2, #+0]
   \   00000014   0x5442             STRB     R2,[R0, R1]
    194                count++;
   \   00000016   0x....             LDR.N    R0,??DataTable2_4
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable2_4
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    195                if(count==4)
   \   00000020   0x....             LDR.N    R0,??DataTable2_4
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD123             BNE.N    ??DMA_RecData_OK_1
    196                {
    197                  if(HeadFlg[0]!=0x33 || HeadFlg[1]!=0x33 || HeadFlg[2]!=0x33 || (HeadFlg[3]!=0x44 && HeadFlg[3]!=0x55))
   \   00000028   0x....             LDR.N    R0,??DataTable2_5
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2833             CMP      R0,#+51
   \   0000002E   0xD10F             BNE.N    ??DMA_RecData_OK_2
   \   00000030   0x....             LDR.N    R0,??DataTable2_5
   \   00000032   0x7840             LDRB     R0,[R0, #+1]
   \   00000034   0x2833             CMP      R0,#+51
   \   00000036   0xD10B             BNE.N    ??DMA_RecData_OK_2
   \   00000038   0x....             LDR.N    R0,??DataTable2_5
   \   0000003A   0x7880             LDRB     R0,[R0, #+2]
   \   0000003C   0x2833             CMP      R0,#+51
   \   0000003E   0xD107             BNE.N    ??DMA_RecData_OK_2
   \   00000040   0x....             LDR.N    R0,??DataTable2_5
   \   00000042   0x78C0             LDRB     R0,[R0, #+3]
   \   00000044   0x2844             CMP      R0,#+68
   \   00000046   0xD073             BEQ.N    ??DMA_RecData_OK_3
   \   00000048   0x....             LDR.N    R0,??DataTable2_5
   \   0000004A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000004C   0x2855             CMP      R0,#+85
   \   0000004E   0xD06F             BEQ.N    ??DMA_RecData_OK_3
    198                  {
    199                    HeadFlg[0]=HeadFlg[1];
   \                     ??DMA_RecData_OK_2:
   \   00000050   0x....             LDR.N    R0,??DataTable2_5
   \   00000052   0x7840             LDRB     R0,[R0, #+1]
   \   00000054   0x....             LDR.N    R1,??DataTable2_5
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    200                    HeadFlg[1]=HeadFlg[2];
   \   00000058   0x....             LDR.N    R0,??DataTable2_5
   \   0000005A   0x....             LDR.N    R1,??DataTable2_5
   \   0000005C   0x7889             LDRB     R1,[R1, #+2]
   \   0000005E   0x7041             STRB     R1,[R0, #+1]
    201                    HeadFlg[2]=HeadFlg[3];
   \   00000060   0x....             LDR.N    R0,??DataTable2_5
   \   00000062   0x....             LDR.N    R1,??DataTable2_5
   \   00000064   0x78C9             LDRB     R1,[R1, #+3]
   \   00000066   0x7081             STRB     R1,[R0, #+2]
    202                    count=3;
   \   00000068   0x....             LDR.N    R0,??DataTable2_4
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   \   0000006E   0xE05F             B.N      ??DMA_RecData_OK_3
    203                  }
    204                }
    205                else if(count==6)
   \                     ??DMA_RecData_OK_1:
   \   00000070   0x....             LDR.N    R0,??DataTable2_4
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x2806             CMP      R0,#+6
   \   00000076   0xD15B             BNE.N    ??DMA_RecData_OK_3
    206                {
    207                  // wk @130420 --> 发送数据 4+2+1+14+2+2532+12+4 = 2571,DMA的数据长度=2571-7=2564，但是数据接收时有两个丢失，故减2
    208                  
    209                  DataSize = (((U16)HeadFlg[4])<<8) + HeadFlg[5]-2;   
   \   00000078   0x....             LDR.N    R0,??DataTable2_5
   \   0000007A   0x7900             LDRB     R0,[R0, #+4]
   \   0000007C   0x0200             LSLS     R0,R0,#+8
   \   0000007E   0x....             LDR.N    R1,??DataTable2_5
   \   00000080   0x7949             LDRB     R1,[R1, #+5]
   \   00000082   0x1840             ADDS     R0,R0,R1
   \   00000084   0x1E80             SUBS     R0,R0,#+2
   \   00000086   0x....             LDR.N    R1,??DataTable2_7
   \   00000088   0x8008             STRH     R0,[R1, #+0]
    210                  count=7;
   \   0000008A   0x....             LDR.N    R0,??DataTable2_4
   \   0000008C   0x2107             MOVS     R1,#+7
   \   0000008E   0x7001             STRB     R1,[R0, #+0]
   \   00000090   0xE04E             B.N      ??DMA_RecData_OK_3
    211                }
    212               
    213              }
    214              else if(count==7)
   \                     ??DMA_RecData_OK_0:
   \   00000092   0x....             LDR.N    R0,??DataTable2_4
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x2807             CMP      R0,#+7
   \   00000098   0xD10A             BNE.N    ??DMA_RecData_OK_4
    215              {
    216                   count=8; // 用一个数据改变 DMA 接收数据的长度，此数据将会被舍弃
   \   0000009A   0x....             LDR.N    R0,??DataTable2_4
   \   0000009C   0x2108             MOVS     R1,#+8
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
    217                   /* wk @130420--> 暂时不考虑发送 */ 
    218                   if(SysSet.EventSendFlg==1)
   \   000000A0   0x....             LDR.N    R0,??DataTable2_8
   \   000000A2   0x7940             LDRB     R0,[R0, #+5]
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD143             BNE.N    ??DMA_RecData_OK_3
    219                   SPI_Send=1; // wk @130406 --> K60是否给DSP发送数据的标志
   \   000000A8   0x....             LDR.N    R0,??DataTable2_9
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0x7001             STRB     R1,[R0, #+0]
   \   000000AE   0xE03F             B.N      ??DMA_RecData_OK_3
    220              }
    221              else
    222              {
    223                /* wk @130408 --> data trans */ 
    224                 if(HeadFlg[3]==0x44) // wk @20130325 -->
   \                     ??DMA_RecData_OK_4:
   \   000000B0   0x....             LDR.N    R0,??DataTable2_5
   \   000000B2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B4   0x2844             CMP      R0,#+68
   \   000000B6   0xD10F             BNE.N    ??DMA_RecData_OK_5
    225                 {
    226                   for(int i=0;i<Pow_SIZE;i++)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE005             B.N      ??DMA_RecData_OK_6
    227                     PowRxchar[i] = BufRxchar[i+OffSET];
   \                     ??DMA_RecData_OK_7:
   \   000000BC   0x....             LDR.N    R1,??DataTable2_6
   \   000000BE   0x1841             ADDS     R1,R0,R1
   \   000000C0   0x7C09             LDRB     R1,[R1, #+16]
   \   000000C2   0x....             LDR.N    R2,??DataTable2_10
   \   000000C4   0x5481             STRB     R1,[R0, R2]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \                     ??DMA_RecData_OK_6:
   \   000000C8   0xF640 0x11E4      MOVW     R1,#+2532
   \   000000CC   0x4288             CMP      R0,R1
   \   000000CE   0xDBF5             BLT.N    ??DMA_RecData_OK_7
    228                    
    229                   SPIPowerFlg=1;
   \   000000D0   0x....             LDR.N    R0,??DataTable2_11
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0x7001             STRB     R1,[R0, #+0]
   \   000000D6   0xE00F             B.N      ??DMA_RecData_OK_8
    230                 }
    231                 else
    232                 {
    233                   for(int i=0;i<Evnt_SIZE;i++)
   \                     ??DMA_RecData_OK_5:
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xE005             B.N      ??DMA_RecData_OK_9
    234                     EvntRxchar[i]= BufRxchar[i+OffSET-2]; //wk @130412 -->将标志也存到数据中
   \                     ??DMA_RecData_OK_10:
   \   000000DC   0x....             LDR.N    R1,??DataTable2_6
   \   000000DE   0x1841             ADDS     R1,R0,R1
   \   000000E0   0x7B89             LDRB     R1,[R1, #+14]
   \   000000E2   0x....             LDR.N    R2,??DataTable2_12
   \   000000E4   0x5481             STRB     R1,[R0, R2]
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \                     ??DMA_RecData_OK_9:
   \   000000E8   0xF641 0x0102      MOVW     R1,#+6146
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xDBF5             BLT.N    ??DMA_RecData_OK_10
    235                   
    236                   SPIEventFlg=1;
   \   000000F0   0x....             LDR.N    R0,??DataTable2_13
   \   000000F2   0x2101             MOVS     R1,#+1
   \   000000F4   0x7001             STRB     R1,[R0, #+0]
    237                   
    238                   /* 事件类型测试 */
    239          //         uchar type;
    240          //         type=EvntRxchar[0]&0x3f;
    241          //         printf("%d\n",type);
    242                   asm("NOP");
   \   000000F6   0xBF00             NOP              
    243          
    244                 }
    245                 
    246                 if(SysSet.EventSendFlg) //wk @130412 -->判断DSP是否成功接收数据
   \                     ??DMA_RecData_OK_8:
   \   000000F8   0x....             LDR.N    R0,??DataTable2_8
   \   000000FA   0x7940             LDRB     R0,[R0, #+5]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD009             BEQ.N    ??DMA_RecData_OK_11
    247                 {
    248                   if(EvntRxchar[0]&0xC0==0xC0)
   \   00000100   0x....             LDR.N    R0,??DataTable2_12
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x07C0             LSLS     R0,R0,#+31
   \   00000106   0xD505             BPL.N    ??DMA_RecData_OK_11
    249                   { 
    250                     SysSet.EventSendFlg=2;    //wk @130412 --> 发送成功       
   \   00000108   0x....             LDR.N    R0,??DataTable2_8
   \   0000010A   0x2102             MOVS     R1,#+2
   \   0000010C   0x7141             STRB     R1,[R0, #+5]
    251                     SPI_Send=0;  
   \   0000010E   0x....             LDR.N    R0,??DataTable2_9
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x7001             STRB     R1,[R0, #+0]
    252                   }
    253                 }
    254                 
    255          #if T_SPI  
    256                  printf("%x\t%x\n",BufRxchar[0],BufRxchar[1]); 
    257          #endif  // END --> T_SPI 
    258                  count=0; 
   \                     ??DMA_RecData_OK_11:
   \   00000114   0x....             LDR.N    R0,??DataTable2_4
   \   00000116   0x2100             MOVS     R1,#+0
   \   00000118   0x7001             STRB     R1,[R0, #+0]
    259                  DataSize=1;
   \   0000011A   0x....             LDR.N    R0,??DataTable2_7
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0x8001             STRH     R1,[R0, #+0]
    260                  fclose(spifd_2);
   \   00000120   0x....             LDR.N    R0,??DataTable2_2
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0x.... 0x....      BL       _io_fclose
    261                  asm("NOP");  
   \   00000128   0xBF00             NOP              
    262                  spi2_dma_int(); // 刷新 DMA 寄存器
   \   0000012A   0x.... 0x....      BL       spi2_dma_int
    263                  asm("NOP");   
   \   0000012E   0xBF00             NOP              
    264              }
    265          #endif
    266              
    267          }
   \                     ??DMA_RecData_OK_3:
   \   00000130   0xBD01             POP      {R0,PC}          ;; return
    268          
    269          /*
    270          ** 函数名：
    271          ** 作者：
    272          ** 说明：在使用事件时 SPI 接收数据的外部任务函数
    273          */

   \                                 In section .text, align 2, keep-with-next
    274          void SPIDMA_Task( uint_32 param)
    275          {
   \                     SPIDMA_Task:
   \   00000000   0xB580             PUSH     {R7,LR}
    276            pointer  pspidma_event;
    277          #ifdef _SPIDMADATA_DBUG_
    278             printf("\n----------SPIDMA_Task----------\n");
   \   00000002   0x....             LDR.N    R0,??DataTable2_14
   \   00000004   0x.... 0x....      BL       _io_printf
    279             printf("\n----------             ----------\n");
   \   00000008   0x....             LDR.N    R0,??DataTable2_15
   \   0000000A   0x.... 0x....      BL       _io_printf
    280             printf("\n----------             ----------\n");
   \   0000000E   0x....             LDR.N    R0,??DataTable2_15
   \   00000010   0x.... 0x....      BL       _io_printf
    281             printf("\n----------     END     ----------\n");
   \   00000014   0x....             LDR.N    R0,??DataTable2_16
   \   00000016   0x.... 0x....      BL       _io_printf
    282          #endif 
    283            
    284          #ifdef _SPIDMADATA_DBUG_
    285              if(_event_create("spidma_event") != MQX_OK){  // 创建事件
   \   0000001A   0x....             LDR.N    R0,??DataTable2_17
   \   0000001C   0x.... 0x....      BL       _event_create
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD005             BEQ.N    ??SPIDMA_Task_0
    286                printf("\n Make spidma event failed");
   \   00000024   0x....             LDR.N    R0,??DataTable2_18
   \   00000026   0x.... 0x....      BL       _io_printf
    287                _task_block();
   \   0000002A   0x.... 0x....      BL       _task_block
   \   0000002E   0xE002             B.N      ??SPIDMA_Task_1
    288              }
    289              else
    290                printf("\n Make spidma event OK");
   \                     ??SPIDMA_Task_0:
   \   00000030   0x....             LDR.N    R0,??DataTable2_19
   \   00000032   0x.... 0x....      BL       _io_printf
    291            
    292            if(_event_open("spidma_event", &pspidma_event) != MQX_OK){
   \                     ??SPIDMA_Task_1:
   \   00000036   0xA900             ADD      R1,SP,#+0
   \   00000038   0x....             LDR.N    R0,??DataTable2_17
   \   0000003A   0x.... 0x....      BL       _event_open
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD005             BEQ.N    ??SPIDMA_Task_2
    293              printf("\nOpen spidma event failed ");
   \   00000042   0x....             LDR.N    R0,??DataTable2_20
   \   00000044   0x.... 0x....      BL       _io_printf
    294              _task_block();
   \   00000048   0x.... 0x....      BL       _task_block
   \   0000004C   0xE013             B.N      ??SPIDMA_Task_3
    295            }  
    296            else
    297              printf("\n Open spidma event OK");
   \                     ??SPIDMA_Task_2:
   \   0000004E   0x....             LDR.N    R0,??DataTable2_21
   \   00000050   0x.... 0x....      BL       _io_printf
   \   00000054   0xE00F             B.N      ??SPIDMA_Task_3
    298          #endif
    299            
    300          #ifndef _SPIDMADATA_DBUG_
    301            _event_create("spidma_event");
    302            _event_open("spidma_event", &pspidma_event);
    303          #endif
    304            
    305            while(TRUE)
    306            {
    307              _event_wait_all(pspidma_event,0x02,0); //等待事件发生
    308              _event_clear(pspidma_event,0x02);  // 清除事件标志
    309            
    310              if(BufRxchar[0]==0x66 && BufRxchar[1]==0x33 && BufRxchar[2]==0x33 && 
    311                 BufRxchar[3]==0x33 && BufRxchar[4]==0x44 && BufRxchar[5]==0x0a&& 
    312                 BufRxchar[6]==0x4c)
    313             { 
    314                for(int i=0 ;i<2635 ;i++)
    315                  PowRxchar[i] = BufRxchar[i+7];
   \                     ??SPIDMA_Task_4:
   \   00000056   0x....             LDR.N    R1,??DataTable2_6
   \   00000058   0x1841             ADDS     R1,R0,R1
   \   0000005A   0x79C9             LDRB     R1,[R1, #+7]
   \   0000005C   0x....             LDR.N    R2,??DataTable2_10
   \   0000005E   0x5481             STRB     R1,[R0, R2]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \                     ??SPIDMA_Task_5:
   \   00000062   0xF640 0x214B      MOVW     R1,#+2635
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xDBF5             BLT.N    ??SPIDMA_Task_4
    316                SPIPowerFlg=1;
   \   0000006A   0x....             LDR.N    R0,??DataTable2_11
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x7001             STRB     R1,[R0, #+0]
    317                printf("1\n");  // @20130312 --> wk: Test the data is OK ?
   \   00000070   0x....             ADR.N    R0,??DataTable2  ;; 0x31, 0x0A, 0x00, 0x00
   \   00000072   0x.... 0x....      BL       _io_printf
   \                     ??SPIDMA_Task_3:
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2102             MOVS     R1,#+2
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x.... 0x....      BL       _event_wait_all
   \   00000080   0x2102             MOVS     R1,#+2
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x.... 0x....      BL       _event_clear
   \   00000088   0x....             LDR.N    R0,??DataTable2_6
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2866             CMP      R0,#+102
   \   0000008E   0xD1F2             BNE.N    ??SPIDMA_Task_3
   \   00000090   0x....             LDR.N    R0,??DataTable2_6
   \   00000092   0x7840             LDRB     R0,[R0, #+1]
   \   00000094   0x2833             CMP      R0,#+51
   \   00000096   0xD1EE             BNE.N    ??SPIDMA_Task_3
   \   00000098   0x....             LDR.N    R0,??DataTable2_6
   \   0000009A   0x7880             LDRB     R0,[R0, #+2]
   \   0000009C   0x2833             CMP      R0,#+51
   \   0000009E   0xD1EA             BNE.N    ??SPIDMA_Task_3
   \   000000A0   0x....             LDR.N    R0,??DataTable2_6
   \   000000A2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000A4   0x2833             CMP      R0,#+51
   \   000000A6   0xD1E6             BNE.N    ??SPIDMA_Task_3
   \   000000A8   0x....             LDR.N    R0,??DataTable2_6
   \   000000AA   0x7900             LDRB     R0,[R0, #+4]
   \   000000AC   0x2844             CMP      R0,#+68
   \   000000AE   0xD1E2             BNE.N    ??SPIDMA_Task_3
   \   000000B0   0x....             LDR.N    R0,??DataTable2_6
   \   000000B2   0x7940             LDRB     R0,[R0, #+5]
   \   000000B4   0x280A             CMP      R0,#+10
   \   000000B6   0xD1DE             BNE.N    ??SPIDMA_Task_3
   \   000000B8   0x....             LDR.N    R0,??DataTable2_6
   \   000000BA   0x7980             LDRB     R0,[R0, #+6]
   \   000000BC   0x284C             CMP      R0,#+76
   \   000000BE   0xD1DA             BNE.N    ??SPIDMA_Task_3
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE7CE             B.N      ??SPIDMA_Task_5
    318            }
    319            
    320          //  printf("2\n");   // @20130312 --> wk: Test if enter the func ?
    321            }
    322              
    323          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x31 0x0A          DC8      0x31, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     `?<Constant "ispi2:">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     spifd_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     `?<Constant "Error opening SPI dri...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     HeadFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     BufRxchar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     DataSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     SysSet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     SPI_Send

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x........         DC32     PowRxchar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x........         DC32     SPIPowerFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x........         DC32     EvntRxchar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x........         DC32     SPIEventFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x........         DC32     `?<Constant "\\n----------SPIDMA_Tas...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x........         DC32     `?<Constant "\\n----------          ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x........         DC32     `?<Constant "\\n----------     END  ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_17:
   \   00000000   0x........         DC32     `?<Constant "spidma_event">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_18:
   \   00000000   0x........         DC32     `?<Constant "\\n Make spidma event f...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_19:
   \   00000000   0x........         DC32     `?<Constant "\\n Make spidma event OK">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_20:
   \   00000000   0x........         DC32     `?<Constant "\\nOpen spidma event fa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_21:
   \   00000000   0x........         DC32     `?<Constant "\\n Open spidma event OK">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "ispi2:">`:
   \   00000000   0x69 0x73          DC8 "ispi2:"
   \              0x70 0x69    
   \              0x32 0x3A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Error opening SPI dri...">`:
   \   00000000   0x45 0x72          DC8 "Error opening SPI driver!\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x53 0x50    
   \              0x49 0x20    
   \              0x64 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \              0x21 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n----------SPIDMA_Tas...">`:
   \   00000000   0x0A 0x2D          DC8 "\012----------SPIDMA_Task----------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x53    
   \              0x50 0x49    
   \              0x44 0x4D    
   \              0x41 0x5F    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n----------          ...">`:
   \   00000000   0x0A 0x2D          DC8 "\012----------             ----------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n----------     END  ...">`:
   \   00000000   0x0A 0x2D          DC8 "\012----------     END     ----------\012"
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x45 0x4E    
   \              0x44 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spidma_event">`:
   \   00000000   0x73 0x70          DC8 "spidma_event"
   \              0x69 0x64    
   \              0x6D 0x61    
   \              0x5F 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n Make spidma event f...">`:
   \   00000000   0x0A 0x20          DC8 "\012 Make spidma event failed"
   \              0x4D 0x61    
   \              0x6B 0x65    
   \              0x20 0x73    
   \              0x70 0x69    
   \              0x64 0x6D    
   \              0x61 0x20    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n Make spidma event OK">`:
   \   00000000   0x0A 0x20          DC8 "\012 Make spidma event OK"
   \              0x4D 0x61    
   \              0x6B 0x65    
   \              0x20 0x73    
   \              0x70 0x69    
   \              0x64 0x6D    
   \              0x61 0x20    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x4F 0x4B    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nOpen spidma event fa...">`:
   \   00000000   0x0A 0x4F          DC8 "\012Open spidma event failed "
   \              0x70 0x65    
   \              0x6E 0x20    
   \              0x73 0x70    
   \              0x69 0x64    
   \              0x6D 0x61    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n Open spidma event OK">`:
   \   00000000   0x0A 0x20          DC8 "\012 Open spidma event OK"
   \              0x4F 0x70    
   \              0x65 0x6E    
   \              0x20 0x73    
   \              0x70 0x69    
   \              0x64 0x6D    
   \              0x61 0x20    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x4F 0x4B    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x31 0x0A          DC8 "1\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  DMA_RecData_OK
              8 -> _io_fclose
              8 -> spi2_dma_int
        8  SPIDMA_Task
              8 -> _event_clear
              8 -> _event_create
              8 -> _event_open
              8 -> _event_wait_all
              8 -> _io_printf
              8 -> _task_block
       24  spi2_dma_int
             24 -> _io_fopen
             24 -> _io_ioctl
             24 -> _io_printf
             24 -> _task_block
             24 -> _time_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "1\n">
      28  ?<Constant "Error opening SPI dri...">
      24  ?<Constant "\n Make spidma event OK">
      28  ?<Constant "\n Make spidma event f...">
      24  ?<Constant "\n Open spidma event OK">
      36  ?<Constant "\n----------          ...">
      36  ?<Constant "\n----------     END  ...">
      36  ?<Constant "\n----------SPIDMA_Tas...">
      28  ?<Constant "\nOpen spidma event fa...">
       8  ?<Constant "ispi2:">
      16  ?<Constant "spidma_event">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_18
       4  ??DataTable2_19
       4  ??DataTable2_2
       4  ??DataTable2_20
       4  ??DataTable2_21
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
    6176  BufRxchar
     306  DMA_RecData_OK
       2  DataSize
    6148  EvntRxchar
       8  HeadFlg
    2532  PowRxchar
     196  SPIDMA_Task
       1  SPIEventFlg
       1  SPIPowerFlg
       1  SPIRxCnt
       1  SPI_Send
       2  TotalNum
       1  count
     116  spi2_dma_int
       4  spifd_2

 
 14 875 bytes in section .bss
      2 bytes in section .data
    268 bytes in section .rodata
    706 bytes in section .text
 
    706 bytes of CODE  memory
    268 bytes of CONST memory
 14 877 bytes of DATA  memory

Errors: none
Warnings: none
